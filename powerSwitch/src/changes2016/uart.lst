   1               		.file	"uart.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 107               	.global	__vector_18
 109               	__vector_18:
   1:uart.c        **** /*************************************************************************
   2:uart.c        **** Title:    Interrupt UART library with receive/transmit circular buffers
   3:uart.c        **** Author:   Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   4:uart.c        **** File:     $Id: uart.c,v 1.6.2.1 2007/07/01 11:14:38 peter Exp $
   5:uart.c        **** Software: AVR-GCC 4.1, AVR Libc 1.4.6 or higher
   6:uart.c        **** Hardware: any AVR with built-in UART, 
   7:uart.c        **** License:  GNU General Public License 
   8:uart.c        ****           
   9:uart.c        **** DESCRIPTION:
  10:uart.c        ****     An interrupt is generated when the UART has finished transmitting or
  11:uart.c        ****     receiving a byte. The interrupt handling routines use circular buffers
  12:uart.c        ****     for buffering received and transmitted data.
  13:uart.c        ****     
  14:uart.c        ****     The UART_RX_BUFFER_SIZE and UART_TX_BUFFER_SIZE variables define
  15:uart.c        ****     the buffer size in bytes. Note that these variables must be a 
  16:uart.c        ****     power of 2.
  17:uart.c        ****     
  18:uart.c        **** USAGE:
  19:uart.c        ****     Refere to the header file uart.h for a description of the routines. 
  20:uart.c        ****     See also example test_uart.c.
  21:uart.c        **** 
  22:uart.c        **** NOTES:
  23:uart.c        ****     Based on Atmel Application Note AVR306
  24:uart.c        ****                     
  25:uart.c        **** LICENSE:
  26:uart.c        ****     Copyright (C) 2006 Peter Fleury
  27:uart.c        **** 
  28:uart.c        ****     This program is free software; you can redistribute it and/or modify
  29:uart.c        ****     it under the terms of the GNU General Public License as published by
  30:uart.c        ****     the Free Software Foundation; either version 2 of the License, or
  31:uart.c        ****     any later version.
  32:uart.c        **** 
  33:uart.c        ****     This program is distributed in the hope that it will be useful,
  34:uart.c        ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  35:uart.c        ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  36:uart.c        ****     GNU General Public License for more details.
  37:uart.c        ****                         
  38:uart.c        **** *************************************************************************/
  39:uart.c        **** 
  40:uart.c        **** /************************************************************************
  41:uart.c        **** uart_available, uart_flush, uart1_available, and uart1_flush functions
  42:uart.c        **** were adapted from the Arduino HardwareSerial.h library by Tim Sharpe on 
  43:uart.c        **** 11 Jan 2009.  The license info for HardwareSerial.h is as follows:
  44:uart.c        **** 
  45:uart.c        ****   HardwareSerial.cpp - Hardware serial library for Wiring
  46:uart.c        ****   Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
  47:uart.c        **** 
  48:uart.c        ****   This library is free software; you can redistribute it and/or
  49:uart.c        ****   modify it under the terms of the GNU Lesser General Public
  50:uart.c        ****   License as published by the Free Software Foundation; either
  51:uart.c        ****   version 2.1 of the License, or (at your option) any later version.
  52:uart.c        **** 
  53:uart.c        ****   This library is distributed in the hope that it will be useful,
  54:uart.c        ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  55:uart.c        ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  56:uart.c        ****   Lesser General Public License for more details.
  57:uart.c        **** 
  58:uart.c        ****   You should have received a copy of the GNU Lesser General Public
  59:uart.c        ****   License along with this library; if not, write to the Free Software
  60:uart.c        ****   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  61:uart.c        ****   
  62:uart.c        ****   Modified 23 November 2006 by David A. Mellis
  63:uart.c        **** ************************************************************************/
  64:uart.c        **** 
  65:uart.c        **** /************************************************************************
  66:uart.c        **** Changelog for modifications made by Tim Sharpe, starting with the current
  67:uart.c        ****   library version on his Web site as of 05/01/2009. 
  68:uart.c        **** 
  69:uart.c        **** Date        Description
  70:uart.c        **** =========================================================================
  71:uart.c        **** 05/11/2009  Changed all existing UARTx_RECEIVE_INTERRUPT and UARTx_TRANSMIT_INTERRUPT
  72:uart.c        ****               macros to use the "_vect" format introduced in AVR-Libc
  73:uart.c        **** 			  v1.4.0.  Had to split the 3290 and 6490 out of their existing
  74:uart.c        **** 			  macro due to an inconsistency in the UART0_RECEIVE_INTERRUPT 
  75:uart.c        **** 			  vector name (seems like a typo: USART_RX_vect for the 3290/6490
  76:uart.c        **** 			  vice USART0_RX_vect for the others in the macro).
  77:uart.c        **** 			Verified all existing macro register names against the device
  78:uart.c        **** 			  header files in AVR-Libc v1.6.6 to catch any inconsistencies.
  79:uart.c        **** 05/12/2009  Added support for 48P, 88P, 168P, and 328P by adding them to the
  80:uart.c        ****                existing 48/88/168 macro.
  81:uart.c        **** 			Added Arduino-style available() and flush() functions for both
  82:uart.c        **** 			supported UARTs.  Really wanted to keep them out of the library, so
  83:uart.c        **** 			that it would be as close as possible to Peter Fleury's original
  84:uart.c        **** 			library, but has scoping issues accessing internal variables from
  85:uart.c        **** 			another program.  Go C!
  86:uart.c        **** 05/13/2009  Changed Interrupt Service Routine label from the old "SIGNAL" to
  87:uart.c        ****                the "ISR" format introduced in AVR-Libc v1.4.0.
  88:uart.c        **** 
  89:uart.c        **** ************************************************************************/
  90:uart.c        **** 
  91:uart.c        **** #include <avr/io.h>
  92:uart.c        **** #include <avr/interrupt.h>
  93:uart.c        **** #include <avr/pgmspace.h>
  94:uart.c        **** #include "uart.h"
  95:uart.c        **** 
  96:uart.c        **** 
  97:uart.c        **** /*
  98:uart.c        ****  *  constants and macros
  99:uart.c        ****  */
 100:uart.c        **** 
 101:uart.c        **** /* size of RX/TX buffers */
 102:uart.c        **** #define UART_RX_BUFFER_MASK ( UART_RX_BUFFER_SIZE - 1)
 103:uart.c        **** #define UART_TX_BUFFER_MASK ( UART_TX_BUFFER_SIZE - 1)
 104:uart.c        **** 
 105:uart.c        **** #if ( UART_RX_BUFFER_SIZE & UART_RX_BUFFER_MASK )
 106:uart.c        **** #error RX buffer size is not a power of 2
 107:uart.c        **** #endif
 108:uart.c        **** #if ( UART_TX_BUFFER_SIZE & UART_TX_BUFFER_MASK )
 109:uart.c        **** #error TX buffer size is not a power of 2
 110:uart.c        **** #endif
 111:uart.c        **** 
 112:uart.c        **** #if defined(__AVR_AT90S2313__) \
 113:uart.c        ****  || defined(__AVR_AT90S4414__) || defined(__AVR_AT90S4434__) \
 114:uart.c        ****  || defined(__AVR_AT90S8515__) || defined(__AVR_AT90S8535__) \
 115:uart.c        ****  || defined(__AVR_ATmega103__)
 116:uart.c        ****  /* old AVR classic or ATmega103 with one UART */
 117:uart.c        ****  #define AT90_UART
 118:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect
 119:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
 120:uart.c        ****  #define UART0_STATUS   USR
 121:uart.c        ****  #define UART0_CONTROL  UCR
 122:uart.c        ****  #define UART0_DATA     UDR  
 123:uart.c        ****  #define UART0_UDRIE    UDRIE
 124:uart.c        **** #elif defined(__AVR_AT90S2333__) || defined(__AVR_AT90S4433__)
 125:uart.c        ****  /* old AVR classic with one UART */
 126:uart.c        ****  #define AT90_UART
 127:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect
 128:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
 129:uart.c        ****  #define UART0_STATUS   UCSRA
 130:uart.c        ****  #define UART0_CONTROL  UCSRB
 131:uart.c        ****  #define UART0_DATA     UDR 
 132:uart.c        ****  #define UART0_UDRIE    UDRIE
 133:uart.c        **** #elif  defined(__AVR_ATmega8__)  || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 134:uart.c        ****   || defined(__AVR_ATmega323__)
 135:uart.c        ****   /* ATmega with one USART */
 136:uart.c        ****  #define ATMEGA_USART
 137:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RXC_vect
 138:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 139:uart.c        ****  #define UART0_STATUS   UCSRA
 140:uart.c        ****  #define UART0_CONTROL  UCSRB
 141:uart.c        ****  #define UART0_DATA     UDR
 142:uart.c        ****  #define UART0_UDRIE    UDRIE
 143:uart.c        **** #elif  defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 144:uart.c        ****   /* ATmega with one USART */
 145:uart.c        ****  #define ATMEGA_USART
 146:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 147:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 148:uart.c        ****  #define UART0_STATUS   UCSRA
 149:uart.c        ****  #define UART0_CONTROL  UCSRB
 150:uart.c        ****  #define UART0_DATA     UDR
 151:uart.c        ****  #define UART0_UDRIE    UDRIE
 152:uart.c        **** #elif defined(__AVR_ATmega163__) 
 153:uart.c        ****   /* ATmega163 with one UART */
 154:uart.c        ****  #define ATMEGA_UART
 155:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect
 156:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
 157:uart.c        ****  #define UART0_STATUS   UCSRA
 158:uart.c        ****  #define UART0_CONTROL  UCSRB
 159:uart.c        ****  #define UART0_DATA     UDR
 160:uart.c        ****  #define UART0_UDRIE    UDRIE
 161:uart.c        **** #elif defined(__AVR_ATmega162__) 
 162:uart.c        ****  /* ATmega with two USART */
 163:uart.c        ****  #define ATMEGA_USART0
 164:uart.c        ****  #define ATMEGA_USART1
 165:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RXC_vect
 166:uart.c        ****  #define UART1_RECEIVE_INTERRUPT   USART1_RXC_vect
 167:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 168:uart.c        ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 169:uart.c        ****  #define UART0_STATUS   UCSR0A
 170:uart.c        ****  #define UART0_CONTROL  UCSR0B
 171:uart.c        ****  #define UART0_DATA     UDR0
 172:uart.c        ****  #define UART0_UDRIE    UDRIE0
 173:uart.c        ****  #define UART1_STATUS   UCSR1A
 174:uart.c        ****  #define UART1_CONTROL  UCSR1B
 175:uart.c        ****  #define UART1_DATA     UDR1
 176:uart.c        ****  #define UART1_UDRIE    UDRIE1
 177:uart.c        **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) 
 178:uart.c        ****  /* ATmega with two USART */
 179:uart.c        ****  #define ATMEGA_USART0
 180:uart.c        ****  #define ATMEGA_USART1
 181:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 182:uart.c        ****  #define UART1_RECEIVE_INTERRUPT   USART1_RX_vect
 183:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 184:uart.c        ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 185:uart.c        ****  #define UART0_STATUS   UCSR0A
 186:uart.c        ****  #define UART0_CONTROL  UCSR0B
 187:uart.c        ****  #define UART0_DATA     UDR0
 188:uart.c        ****  #define UART0_UDRIE    UDRIE0
 189:uart.c        ****  #define UART1_STATUS   UCSR1A
 190:uart.c        ****  #define UART1_CONTROL  UCSR1B
 191:uart.c        ****  #define UART1_DATA     UDR1
 192:uart.c        ****  #define UART1_UDRIE    UDRIE1
 193:uart.c        **** #elif defined(__AVR_ATmega161__)
 194:uart.c        ****  /* ATmega with UART */
 195:uart.c        ****  #error "AVR ATmega161 currently not supported by this libaray !"
 196:uart.c        **** #elif defined(__AVR_ATmega169__) 
 197:uart.c        ****  /* ATmega with one USART */
 198:uart.c        ****  #define ATMEGA_USART
 199:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 200:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 201:uart.c        ****  #define UART0_STATUS   UCSRA
 202:uart.c        ****  #define UART0_CONTROL  UCSRB
 203:uart.c        ****  #define UART0_DATA     UDR
 204:uart.c        ****  #define UART0_UDRIE    UDRIE
 205:uart.c        **** #elif defined(__AVR_ATmega48__) ||defined(__AVR_ATmega88__) || defined(__AVR_ATmega168__) || \
 206:uart.c        ****       defined(__AVR_ATmega48P__) ||defined(__AVR_ATmega88P__) || defined(__AVR_ATmega168P__) || \
 207:uart.c        ****       defined(__AVR_ATmega328P__) 
 208:uart.c        ****  /* TLS-Added 48P/88P/168P/328P */
 209:uart.c        ****  /* ATmega with one USART */
 210:uart.c        ****  #define ATMEGA_USART0
 211:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 212:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 213:uart.c        ****  #define UART0_STATUS   UCSR0A
 214:uart.c        ****  #define UART0_CONTROL  UCSR0B
 215:uart.c        ****  #define UART0_DATA     UDR0
 216:uart.c        ****  #define UART0_UDRIE    UDRIE0
 217:uart.c        **** #elif defined(__AVR_ATtiny2313__)
 218:uart.c        ****  #define ATMEGA_USART
 219:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect 
 220:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 221:uart.c        ****  #define UART0_STATUS   UCSRA
 222:uart.c        ****  #define UART0_CONTROL  UCSRB
 223:uart.c        ****  #define UART0_DATA     UDR
 224:uart.c        ****  #define UART0_UDRIE    UDRIE
 225:uart.c        **** #elif defined(__AVR_ATmega329__) ||\
 226:uart.c        ****       defined(__AVR_ATmega649__) ||\
 227:uart.c        ****       defined(__AVR_ATmega325__) ||defined(__AVR_ATmega3250__) ||\
 228:uart.c        ****       defined(__AVR_ATmega645__) ||defined(__AVR_ATmega6450__)
 229:uart.c        ****   /* ATmega with one USART */
 230:uart.c        ****   #define ATMEGA_USART0
 231:uart.c        ****   #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 232:uart.c        ****   #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 233:uart.c        ****   #define UART0_STATUS   UCSR0A
 234:uart.c        ****   #define UART0_CONTROL  UCSR0B
 235:uart.c        ****   #define UART0_DATA     UDR0
 236:uart.c        ****   #define UART0_UDRIE    UDRIE0
 237:uart.c        **** #elif defined(__AVR_ATmega3290__) ||\
 238:uart.c        ****       defined(__AVR_ATmega6490__)
 239:uart.c        ****   /* TLS-Separated these two from the previous group because of inconsistency in the USART_RX */
 240:uart.c        ****   /* ATmega with one USART */
 241:uart.c        ****   #define ATMEGA_USART0
 242:uart.c        ****   #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 243:uart.c        ****   #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 244:uart.c        ****   #define UART0_STATUS   UCSR0A
 245:uart.c        ****   #define UART0_CONTROL  UCSR0B
 246:uart.c        ****   #define UART0_DATA     UDR0
 247:uart.c        ****   #define UART0_UDRIE    UDRIE0
 248:uart.c        **** #elif defined(__AVR_ATmega2560__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega640__)
 249:uart.c        **** /* ATmega with two USART */
 250:uart.c        ****   #define ATMEGA_USART0
 251:uart.c        ****   #define ATMEGA_USART1
 252:uart.c        ****   #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 253:uart.c        ****   #define UART1_RECEIVE_INTERRUPT   USART0_UDRE_vect
 254:uart.c        ****   #define UART0_TRANSMIT_INTERRUPT  USART1_RX_vect
 255:uart.c        ****   #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 256:uart.c        ****   #define UART0_STATUS   UCSR0A
 257:uart.c        ****   #define UART0_CONTROL  UCSR0B
 258:uart.c        ****   #define UART0_DATA     UDR0
 259:uart.c        ****   #define UART0_UDRIE    UDRIE0
 260:uart.c        ****   #define UART1_STATUS   UCSR1A
 261:uart.c        ****   #define UART1_CONTROL  UCSR1B
 262:uart.c        ****   #define UART1_DATA     UDR1
 263:uart.c        ****   #define UART1_UDRIE    UDRIE1  
 264:uart.c        **** #elif defined(__AVR_ATmega644__)
 265:uart.c        ****  /* ATmega with one USART */
 266:uart.c        ****  #define ATMEGA_USART0
 267:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 268:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 269:uart.c        ****  #define UART0_STATUS   UCSR0A
 270:uart.c        ****  #define UART0_CONTROL  UCSR0B
 271:uart.c        ****  #define UART0_DATA     UDR0
 272:uart.c        ****  #define UART0_UDRIE    UDRIE0
 273:uart.c        **** #elif defined(__AVR_ATmega164P__) || defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__)
 274:uart.c        ****  /* ATmega with two USART */
 275:uart.c        ****  #define ATMEGA_USART0
 276:uart.c        ****  #define ATMEGA_USART1
 277:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 278:uart.c        ****  #define UART1_RECEIVE_INTERRUPT   USART0_UDRE_vect
 279:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART1_RX_vect
 280:uart.c        ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 281:uart.c        ****  #define UART0_STATUS   UCSR0A
 282:uart.c        ****  #define UART0_CONTROL  UCSR0B
 283:uart.c        ****  #define UART0_DATA     UDR0
 284:uart.c        ****  #define UART0_UDRIE    UDRIE0
 285:uart.c        ****  #define UART1_STATUS   UCSR1A
 286:uart.c        ****  #define UART1_CONTROL  UCSR1B
 287:uart.c        ****  #define UART1_DATA     UDR1
 288:uart.c        ****  #define UART1_UDRIE    UDRIE1
 289:uart.c        **** #else
 290:uart.c        ****  #error "no UART definition for MCU available"
 291:uart.c        **** #endif
 292:uart.c        **** 
 293:uart.c        **** 
 294:uart.c        **** /*
 295:uart.c        ****  *  module global variables
 296:uart.c        ****  */
 297:uart.c        **** static volatile unsigned char UART_TxBuf[UART_TX_BUFFER_SIZE];
 298:uart.c        **** static volatile unsigned char UART_RxBuf[UART_RX_BUFFER_SIZE];
 299:uart.c        **** static volatile unsigned char UART_TxHead;
 300:uart.c        **** static volatile unsigned char UART_TxTail;
 301:uart.c        **** static volatile unsigned char UART_RxHead;
 302:uart.c        **** static volatile unsigned char UART_RxTail;
 303:uart.c        **** static volatile unsigned char UART_LastRxError;
 304:uart.c        **** 
 305:uart.c        **** #if defined( ATMEGA_USART1 )
 306:uart.c        **** static volatile unsigned char UART1_TxBuf[UART_TX_BUFFER_SIZE];
 307:uart.c        **** static volatile unsigned char UART1_RxBuf[UART_RX_BUFFER_SIZE];
 308:uart.c        **** static volatile unsigned char UART1_TxHead;
 309:uart.c        **** static volatile unsigned char UART1_TxTail;
 310:uart.c        **** static volatile unsigned char UART1_RxHead;
 311:uart.c        **** static volatile unsigned char UART1_RxTail;
 312:uart.c        **** static volatile unsigned char UART1_LastRxError;
 313:uart.c        **** #endif
 314:uart.c        **** 
 315:uart.c        **** 
 316:uart.c        **** 
 317:uart.c        **** ISR(UART0_RECEIVE_INTERRUPT)
 318:uart.c        **** /*************************************************************************
 319:uart.c        **** Function: UART Receive Complete interrupt
 320:uart.c        **** Purpose:  called when the UART has received a character
 321:uart.c        **** **************************************************************************/
 322:uart.c        **** {
 111               	.LM0:
 112               	.LFBB1:
 113 0000 1F92      		push r1
 114 0002 0F92      		push r0
 115 0004 0FB6      		in r0,__SREG__
 116 0006 0F92      		push r0
 117 0008 1124      		clr __zero_reg__
 118 000a 2F93      		push r18
 119 000c 8F93      		push r24
 120 000e 9F93      		push r25
 121 0010 EF93      		push r30
 122 0012 FF93      		push r31
 123               	/* prologue: Signal */
 124               	/* frame size = 0 */
 125               	/* stack size = 8 */
 126               	.L__stack_usage = 8
 323:uart.c        ****     unsigned char tmphead;
 324:uart.c        ****     unsigned char data;
 325:uart.c        ****     unsigned char usr;
 326:uart.c        ****     unsigned char lastRxError;
 327:uart.c        ****  
 328:uart.c        ****  
 329:uart.c        ****     /* read UART status register and UART data register */ 
 330:uart.c        ****     usr  = UART0_STATUS;
 128               	.LM1:
 129 0014 8091 C000 		lds r24,192
 331:uart.c        ****     data = UART0_DATA;
 131               	.LM2:
 132 0018 9091 C600 		lds r25,198
 332:uart.c        ****     
 333:uart.c        ****     /* */
 334:uart.c        **** #if defined( AT90_UART )
 335:uart.c        ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 336:uart.c        **** #elif defined( ATMEGA_USART )
 337:uart.c        ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 338:uart.c        **** #elif defined( ATMEGA_USART0 )
 339:uart.c        ****     lastRxError = (usr & (_BV(FE0)|_BV(DOR0)) );
 134               	.LM3:
 135 001c 8871      		andi r24,lo8(24)
 340:uart.c        **** #elif defined ( ATMEGA_UART )
 341:uart.c        ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 342:uart.c        **** #endif
 343:uart.c        ****         
 344:uart.c        ****     /* calculate buffer index */ 
 345:uart.c        ****     tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
 137               	.LM4:
 138 001e E091 0000 		lds r30,UART_RxHead
 139 0022 EF5F      		subi r30,lo8(-(1))
 140 0024 EF71      		andi r30,lo8(31)
 346:uart.c        ****     
 347:uart.c        ****     if ( tmphead == UART_RxTail ) {
 142               	.LM5:
 143 0026 2091 0000 		lds r18,UART_RxTail
 144 002a E217      		cp r30,r18
 145 002c 01F0      		breq .L3
 348:uart.c        ****         /* error: receive buffer overflow */
 349:uart.c        ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
 350:uart.c        ****     }else{
 351:uart.c        ****         /* store new index */
 352:uart.c        ****         UART_RxHead = tmphead;
 147               	.LM6:
 148 002e E093 0000 		sts UART_RxHead,r30
 353:uart.c        ****         /* store received data in buffer */
 354:uart.c        ****         UART_RxBuf[tmphead] = data;
 150               	.LM7:
 151 0032 F0E0      		ldi r31,0
 152 0034 E050      		subi r30,lo8(-(UART_RxBuf))
 153 0036 F040      		sbci r31,hi8(-(UART_RxBuf))
 154 0038 9083      		st Z,r25
 155 003a 00C0      		rjmp .L2
 156               	.L3:
 349:uart.c        ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
 158               	.LM8:
 159 003c 82E0      		ldi r24,lo8(2)
 160               	.L2:
 355:uart.c        ****     }
 356:uart.c        ****     UART_LastRxError = lastRxError;   
 162               	.LM9:
 163 003e 8093 0000 		sts UART_LastRxError,r24
 164               	/* epilogue start */
 357:uart.c        **** }
 166               	.LM10:
 167 0042 FF91      		pop r31
 168 0044 EF91      		pop r30
 169 0046 9F91      		pop r25
 170 0048 8F91      		pop r24
 171 004a 2F91      		pop r18
 172 004c 0F90      		pop r0
 173 004e 0FBE      		out __SREG__,r0
 174 0050 0F90      		pop r0
 175 0052 1F90      		pop r1
 176 0054 1895      		reti
 183               	.Lscope1:
 185               	.global	__vector_19
 187               	__vector_19:
 358:uart.c        **** 
 359:uart.c        **** 
 360:uart.c        **** ISR(UART0_TRANSMIT_INTERRUPT)
 361:uart.c        **** /*************************************************************************
 362:uart.c        **** Function: UART Data Register Empty interrupt
 363:uart.c        **** Purpose:  called when the UART is ready to transmit the next byte
 364:uart.c        **** **************************************************************************/
 365:uart.c        **** {
 189               	.LM11:
 190               	.LFBB2:
 191 0056 1F92      		push r1
 192 0058 0F92      		push r0
 193 005a 0FB6      		in r0,__SREG__
 194 005c 0F92      		push r0
 195 005e 1124      		clr __zero_reg__
 196 0060 8F93      		push r24
 197 0062 9F93      		push r25
 198 0064 EF93      		push r30
 199 0066 FF93      		push r31
 200               	/* prologue: Signal */
 201               	/* frame size = 0 */
 202               	/* stack size = 7 */
 203               	.L__stack_usage = 7
 366:uart.c        ****     unsigned char tmptail;
 367:uart.c        **** 
 368:uart.c        ****     
 369:uart.c        ****     if ( UART_TxHead != UART_TxTail) {
 205               	.LM12:
 206 0068 9091 0000 		lds r25,UART_TxHead
 207 006c 8091 0000 		lds r24,UART_TxTail
 208 0070 9817      		cp r25,r24
 209 0072 01F0      		breq .L6
 370:uart.c        ****         /* calculate and store new buffer index */
 371:uart.c        ****         tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 211               	.LM13:
 212 0074 E091 0000 		lds r30,UART_TxTail
 213 0078 EF5F      		subi r30,lo8(-(1))
 214 007a EF71      		andi r30,lo8(31)
 372:uart.c        ****         UART_TxTail = tmptail;
 216               	.LM14:
 217 007c E093 0000 		sts UART_TxTail,r30
 373:uart.c        ****         /* get one byte from buffer and write it to UART */
 374:uart.c        ****         UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 219               	.LM15:
 220 0080 F0E0      		ldi r31,0
 221 0082 E050      		subi r30,lo8(-(UART_TxBuf))
 222 0084 F040      		sbci r31,hi8(-(UART_TxBuf))
 223 0086 8081      		ld r24,Z
 224 0088 8093 C600 		sts 198,r24
 225 008c 00C0      		rjmp .L5
 226               	.L6:
 375:uart.c        ****     }else{
 376:uart.c        ****         /* tx buffer empty, disable UDRE interrupt */
 377:uart.c        ****         UART0_CONTROL &= ~_BV(UART0_UDRIE);
 228               	.LM16:
 229 008e 8091 C100 		lds r24,193
 230 0092 8F7D      		andi r24,lo8(-33)
 231 0094 8093 C100 		sts 193,r24
 232               	.L5:
 233               	/* epilogue start */
 378:uart.c        ****     }
 379:uart.c        **** }
 235               	.LM17:
 236 0098 FF91      		pop r31
 237 009a EF91      		pop r30
 238 009c 9F91      		pop r25
 239 009e 8F91      		pop r24
 240 00a0 0F90      		pop r0
 241 00a2 0FBE      		out __SREG__,r0
 242 00a4 0F90      		pop r0
 243 00a6 1F90      		pop r1
 244 00a8 1895      		reti
 249               	.Lscope2:
 252               	.global	uart_init
 254               	uart_init:
 380:uart.c        **** 
 381:uart.c        **** 
 382:uart.c        **** /*************************************************************************
 383:uart.c        **** Function: uart_init()
 384:uart.c        **** Purpose:  initialize UART and set baudrate
 385:uart.c        **** Input:    baudrate using macro UART_BAUD_SELECT()
 386:uart.c        **** Returns:  none
 387:uart.c        **** **************************************************************************/
 388:uart.c        **** void uart_init(unsigned int baudrate)
 389:uart.c        **** {
 256               	.LM18:
 257               	.LFBB3:
 258               	/* prologue: function */
 259               	/* frame size = 0 */
 260               	/* stack size = 0 */
 261               	.L__stack_usage = 0
 390:uart.c        ****     UART_TxHead = 0;
 263               	.LM19:
 264 00aa 1092 0000 		sts UART_TxHead,__zero_reg__
 391:uart.c        ****     UART_TxTail = 0;
 266               	.LM20:
 267 00ae 1092 0000 		sts UART_TxTail,__zero_reg__
 392:uart.c        ****     UART_RxHead = 0;
 269               	.LM21:
 270 00b2 1092 0000 		sts UART_RxHead,__zero_reg__
 393:uart.c        ****     UART_RxTail = 0;
 272               	.LM22:
 273 00b6 1092 0000 		sts UART_RxTail,__zero_reg__
 394:uart.c        ****     
 395:uart.c        **** #if defined( AT90_UART )
 396:uart.c        ****     /* set baud rate */
 397:uart.c        ****     UBRR = (unsigned char)baudrate; 
 398:uart.c        **** 
 399:uart.c        ****     /* enable UART receiver and transmmitter and receive complete interrupt */
 400:uart.c        ****     UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);
 401:uart.c        **** 
 402:uart.c        **** #elif defined (ATMEGA_USART)
 403:uart.c        ****     /* Set baud rate */
 404:uart.c        ****     if ( baudrate & 0x8000 )
 405:uart.c        ****     {
 406:uart.c        ****     	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
 407:uart.c        ****     	 baudrate &= ~0x8000;
 408:uart.c        ****     }
 409:uart.c        ****     UBRRH = (unsigned char)(baudrate>>8);
 410:uart.c        ****     UBRRL = (unsigned char) baudrate;
 411:uart.c        ****    
 412:uart.c        ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 413:uart.c        ****     UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
 414:uart.c        ****     
 415:uart.c        ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 416:uart.c        ****     #ifdef URSEL
 417:uart.c        ****     UCSRC = (1<<URSEL)|(3<<UCSZ0);
 418:uart.c        ****     #else
 419:uart.c        ****     UCSRC = (3<<UCSZ0);
 420:uart.c        ****     #endif 
 421:uart.c        ****     
 422:uart.c        **** #elif defined (ATMEGA_USART0 )
 423:uart.c        ****     /* Set baud rate */
 424:uart.c        ****     if ( baudrate & 0x8000 ) 
 275               	.LM23:
 276 00ba 97FF      		sbrs r25,7
 277 00bc 00C0      		rjmp .L9
 425:uart.c        ****     {
 426:uart.c        ****    		UART0_STATUS = (1<<U2X0);  //Enable 2x speed 
 279               	.LM24:
 280 00be 22E0      		ldi r18,lo8(2)
 281 00c0 2093 C000 		sts 192,r18
 427:uart.c        ****    		baudrate &= ~0x8000;
 283               	.LM25:
 284 00c4 9F77      		andi r25,127
 285               	.L9:
 428:uart.c        ****    	}
 429:uart.c        ****     UBRR0H = (unsigned char)(baudrate>>8);
 287               	.LM26:
 288 00c6 9093 C500 		sts 197,r25
 430:uart.c        ****     UBRR0L = (unsigned char) baudrate;
 290               	.LM27:
 291 00ca 8093 C400 		sts 196,r24
 431:uart.c        **** 
 432:uart.c        ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 433:uart.c        ****     UART0_CONTROL = _BV(RXCIE0)|(1<<RXEN0)|(1<<TXEN0);
 293               	.LM28:
 294 00ce 88E9      		ldi r24,lo8(-104)
 295 00d0 8093 C100 		sts 193,r24
 434:uart.c        ****     
 435:uart.c        ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 436:uart.c        ****     #ifdef URSEL0
 437:uart.c        ****     UCSR0C = (1<<URSEL0)|(3<<UCSZ00);
 438:uart.c        ****     #else
 439:uart.c        ****     UCSR0C = (3<<UCSZ00);
 297               	.LM29:
 298 00d4 86E0      		ldi r24,lo8(6)
 299 00d6 8093 C200 		sts 194,r24
 300 00da 0895      		ret
 302               	.Lscope3:
 304               	.global	uart_getc
 306               	uart_getc:
 440:uart.c        ****     #endif 
 441:uart.c        **** 
 442:uart.c        **** #elif defined ( ATMEGA_UART )
 443:uart.c        ****     /* set baud rate */
 444:uart.c        ****     if ( baudrate & 0x8000 ) 
 445:uart.c        ****     {
 446:uart.c        ****     	UART0_STATUS = (1<<U2X);  //Enable 2x speed 
 447:uart.c        ****     	baudrate &= ~0x8000;
 448:uart.c        ****     }
 449:uart.c        ****     UBRRHI = (unsigned char)(baudrate>>8);
 450:uart.c        ****     UBRR   = (unsigned char) baudrate;
 451:uart.c        **** 
 452:uart.c        ****     /* Enable UART receiver and transmitter and receive complete interrupt */
 453:uart.c        ****     UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
 454:uart.c        **** 
 455:uart.c        **** #endif
 456:uart.c        **** 
 457:uart.c        **** }/* uart_init */
 458:uart.c        **** 
 459:uart.c        **** 
 460:uart.c        **** /*************************************************************************
 461:uart.c        **** Function: uart_getc()
 462:uart.c        **** Purpose:  return byte from ringbuffer  
 463:uart.c        **** Returns:  lower byte:  received byte from ringbuffer
 464:uart.c        ****           higher byte: last receive error
 465:uart.c        **** **************************************************************************/
 466:uart.c        **** unsigned int uart_getc(void)
 467:uart.c        **** {    
 308               	.LM30:
 309               	.LFBB4:
 310               	/* prologue: function */
 311               	/* frame size = 0 */
 312               	/* stack size = 0 */
 313               	.L__stack_usage = 0
 468:uart.c        ****     unsigned char tmptail;
 469:uart.c        ****     unsigned char data;
 470:uart.c        **** 
 471:uart.c        **** 
 472:uart.c        ****     if ( UART_RxHead == UART_RxTail ) {
 315               	.LM31:
 316 00dc 9091 0000 		lds r25,UART_RxHead
 317 00e0 8091 0000 		lds r24,UART_RxTail
 318 00e4 9817      		cp r25,r24
 319 00e6 01F0      		breq .L12
 473:uart.c        ****         return UART_NO_DATA;   /* no data available */
 474:uart.c        ****     }
 475:uart.c        ****     
 476:uart.c        ****     /* calculate /store buffer index */
 477:uart.c        ****     tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
 321               	.LM32:
 322 00e8 E091 0000 		lds r30,UART_RxTail
 323 00ec EF5F      		subi r30,lo8(-(1))
 324 00ee EF71      		andi r30,lo8(31)
 478:uart.c        ****     UART_RxTail = tmptail; 
 326               	.LM33:
 327 00f0 E093 0000 		sts UART_RxTail,r30
 479:uart.c        ****     
 480:uart.c        ****     /* get data from receive buffer */
 481:uart.c        ****     data = UART_RxBuf[tmptail];
 329               	.LM34:
 330 00f4 F0E0      		ldi r31,0
 331 00f6 E050      		subi r30,lo8(-(UART_RxBuf))
 332 00f8 F040      		sbci r31,hi8(-(UART_RxBuf))
 333 00fa 2081      		ld r18,Z
 482:uart.c        ****     
 483:uart.c        ****     return (UART_LastRxError << 8) + data;
 335               	.LM35:
 336 00fc 8091 0000 		lds r24,UART_LastRxError
 337 0100 90E0      		ldi r25,0
 338 0102 982F      		mov r25,r24
 339 0104 8827      		clr r24
 340 0106 820F      		add r24,r18
 341 0108 911D      		adc r25,__zero_reg__
 342 010a 0895      		ret
 343               	.L12:
 473:uart.c        ****         return UART_NO_DATA;   /* no data available */
 345               	.LM36:
 346 010c 80E0      		ldi r24,0
 347 010e 91E0      		ldi r25,lo8(1)
 484:uart.c        **** 
 485:uart.c        **** }/* uart_getc */
 349               	.LM37:
 350 0110 0895      		ret
 356               	.Lscope4:
 359               	.global	uart_putc
 361               	uart_putc:
 486:uart.c        **** 
 487:uart.c        **** 
 488:uart.c        **** /*************************************************************************
 489:uart.c        **** Function: uart_putc()
 490:uart.c        **** Purpose:  write byte to ringbuffer for transmitting via UART
 491:uart.c        **** Input:    byte to be transmitted
 492:uart.c        **** Returns:  none          
 493:uart.c        **** **************************************************************************/
 494:uart.c        **** void uart_putc(unsigned char data)
 495:uart.c        **** {
 363               	.LM38:
 364               	.LFBB5:
 365               	/* prologue: function */
 366               	/* frame size = 0 */
 367               	/* stack size = 0 */
 368               	.L__stack_usage = 0
 496:uart.c        ****     unsigned char tmphead;
 497:uart.c        **** 
 498:uart.c        ****     
 499:uart.c        ****     tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 370               	.LM39:
 371 0112 9091 0000 		lds r25,UART_TxHead
 372 0116 9F5F      		subi r25,lo8(-(1))
 373 0118 9F71      		andi r25,lo8(31)
 374               	.L15:
 500:uart.c        ****     
 501:uart.c        ****     while ( tmphead == UART_TxTail ){
 376               	.LM40:
 377 011a 2091 0000 		lds r18,UART_TxTail
 378 011e 9217      		cp r25,r18
 379 0120 01F0      		breq .L15
 502:uart.c        ****         ;/* wait for free space in buffer */
 503:uart.c        ****     }
 504:uart.c        ****     
 505:uart.c        ****     UART_TxBuf[tmphead] = data;
 381               	.LM41:
 382 0122 E92F      		mov r30,r25
 383 0124 F0E0      		ldi r31,0
 384 0126 E050      		subi r30,lo8(-(UART_TxBuf))
 385 0128 F040      		sbci r31,hi8(-(UART_TxBuf))
 386 012a 8083      		st Z,r24
 506:uart.c        ****     UART_TxHead = tmphead;
 388               	.LM42:
 389 012c 9093 0000 		sts UART_TxHead,r25
 507:uart.c        **** 
 508:uart.c        ****     /* enable UDRE interrupt */
 509:uart.c        ****     UART0_CONTROL    |= _BV(UART0_UDRIE);
 391               	.LM43:
 392 0130 8091 C100 		lds r24,193
 393 0134 8062      		ori r24,lo8(32)
 394 0136 8093 C100 		sts 193,r24
 395 013a 0895      		ret
 400               	.Lscope5:
 403               	.global	uart_puts
 405               	uart_puts:
 510:uart.c        **** 
 511:uart.c        **** }/* uart_putc */
 512:uart.c        **** 
 513:uart.c        **** 
 514:uart.c        **** /*************************************************************************
 515:uart.c        **** Function: uart_puts()
 516:uart.c        **** Purpose:  transmit string to UART
 517:uart.c        **** Input:    string to be transmitted
 518:uart.c        **** Returns:  none          
 519:uart.c        **** **************************************************************************/
 520:uart.c        **** void uart_puts(const char *s )
 521:uart.c        **** {
 407               	.LM44:
 408               	.LFBB6:
 409 013c CF93      		push r28
 410 013e DF93      		push r29
 411               	/* prologue: function */
 412               	/* frame size = 0 */
 413               	/* stack size = 2 */
 414               	.L__stack_usage = 2
 415 0140 EC01      		movw r28,r24
 416               	.L17:
 522:uart.c        ****     while (*s) 
 418               	.LM45:
 419 0142 8991      		ld r24,Y+
 420 0144 8823      		tst r24
 421 0146 01F0      		breq .L19
 523:uart.c        ****       uart_putc(*s++);
 423               	.LM46:
 424 0148 0E94 0000 		call uart_putc
 425 014c 00C0      		rjmp .L17
 426               	.L19:
 427               	/* epilogue start */
 524:uart.c        **** 
 525:uart.c        **** }/* uart_puts */
 429               	.LM47:
 430 014e DF91      		pop r29
 431 0150 CF91      		pop r28
 432 0152 0895      		ret
 434               	.Lscope6:
 437               	.global	uart_puts_p
 439               	uart_puts_p:
 526:uart.c        **** 
 527:uart.c        **** 
 528:uart.c        **** /*************************************************************************
 529:uart.c        **** Function: uart_puts_p()
 530:uart.c        **** Purpose:  transmit string from program memory to UART
 531:uart.c        **** Input:    program memory string to be transmitted
 532:uart.c        **** Returns:  none
 533:uart.c        **** **************************************************************************/
 534:uart.c        **** void uart_puts_p(const char *progmem_s )
 535:uart.c        **** {
 441               	.LM48:
 442               	.LFBB7:
 443 0154 CF93      		push r28
 444 0156 DF93      		push r29
 445               	/* prologue: function */
 446               	/* frame size = 0 */
 447               	/* stack size = 2 */
 448               	.L__stack_usage = 2
 449 0158 FC01      		movw r30,r24
 450               	.L21:
 451               	.LBB2:
 536:uart.c        ****     register char c;
 537:uart.c        ****     
 538:uart.c        ****     while ( (c = pgm_read_byte(progmem_s++)) ) 
 453               	.LM49:
 454               	/* #APP */
 455               	 ;  538 "uart.c" 1
 456 015a 8491      		lpm r24, Z
 457               		
 458               	 ;  0 "" 2
 459               	/* #NOAPP */
 460 015c EF01      		movw r28,r30
 461 015e 2196      		adiw r28,1
 462               	.LBE2:
 463 0160 8823      		tst r24
 464 0162 01F0      		breq .L23
 539:uart.c        ****       uart_putc(c);
 466               	.LM50:
 467 0164 0E94 0000 		call uart_putc
 468 0168 FE01      		movw r30,r28
 469 016a 00C0      		rjmp .L21
 470               	.L23:
 471               	/* epilogue start */
 540:uart.c        **** 
 541:uart.c        **** }/* uart_puts_p */
 473               	.LM51:
 474 016c DF91      		pop r29
 475 016e CF91      		pop r28
 476 0170 0895      		ret
 481               	.Lscope7:
 483               	.global	uart_available
 485               	uart_available:
 542:uart.c        **** 
 543:uart.c        **** 
 544:uart.c        **** 
 545:uart.c        **** /*************************************************************************
 546:uart.c        **** Function: uart_available()
 547:uart.c        **** Purpose:  Determine the number of bytes waiting in the receive buffer
 548:uart.c        **** Input:    None
 549:uart.c        **** Returns:  Integer number of bytes in the receive buffer
 550:uart.c        **** **************************************************************************/
 551:uart.c        **** int uart_available(void)
 552:uart.c        **** {
 487               	.LM52:
 488               	.LFBB8:
 489               	/* prologue: function */
 490               	/* frame size = 0 */
 491               	/* stack size = 0 */
 492               	.L__stack_usage = 0
 553:uart.c        ****         return (UART_RX_BUFFER_MASK + UART_RxHead - UART_RxTail) % UART_RX_BUFFER_MASK;
 494               	.LM53:
 495 0172 8091 0000 		lds r24,UART_RxHead
 496 0176 2091 0000 		lds r18,UART_RxTail
 497 017a 90E0      		ldi r25,0
 498 017c 4F96      		adiw r24,31
 499 017e 821B      		sub r24,r18
 500 0180 9109      		sbc r25,__zero_reg__
 501 0182 6FE1      		ldi r22,lo8(31)
 502 0184 70E0      		ldi r23,0
 503 0186 0E94 0000 		call __divmodhi4
 554:uart.c        **** }/* uart_available */
 505               	.LM54:
 506 018a 0895      		ret
 508               	.Lscope8:
 510               	.global	uart_flush
 512               	uart_flush:
 555:uart.c        **** 
 556:uart.c        **** 
 557:uart.c        **** 
 558:uart.c        **** /*************************************************************************
 559:uart.c        **** Function: uart_flush()
 560:uart.c        **** Purpose:  Flush bytes waiting the receive buffer.  Acutally ignores them.
 561:uart.c        **** Input:    None
 562:uart.c        **** Returns:  None
 563:uart.c        **** **************************************************************************/
 564:uart.c        **** void uart_flush(void)
 565:uart.c        **** {
 514               	.LM55:
 515               	.LFBB9:
 516               	/* prologue: function */
 517               	/* frame size = 0 */
 518               	/* stack size = 0 */
 519               	.L__stack_usage = 0
 566:uart.c        ****         UART_RxHead = UART_RxTail;
 521               	.LM56:
 522 018c 8091 0000 		lds r24,UART_RxTail
 523 0190 8093 0000 		sts UART_RxHead,r24
 524 0194 0895      		ret
 526               	.Lscope9:
 527               		.local	UART_LastRxError
 528               		.comm	UART_LastRxError,1,1
 529               		.local	UART_RxTail
 530               		.comm	UART_RxTail,1,1
 531               		.local	UART_RxHead
 532               		.comm	UART_RxHead,1,1
 533               		.local	UART_TxTail
 534               		.comm	UART_TxTail,1,1
 535               		.local	UART_TxHead
 536               		.comm	UART_TxHead,1,1
 537               		.local	UART_RxBuf
 538               		.comm	UART_RxBuf,32,1
 539               		.local	UART_TxBuf
 540               		.comm	UART_TxBuf,32,1
 549               	.Letext0:
 550               		.ident	"GCC: (GNU) 4.8.2"
 551               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 uart.c
     /tmp/ccSYqJT4.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccSYqJT4.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccSYqJT4.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccSYqJT4.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccSYqJT4.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccSYqJT4.s:109    .text:0000000000000000 __vector_18
     /tmp/ccSYqJT4.s:530    .bss:0000000000000002 UART_RxHead
     /tmp/ccSYqJT4.s:528    .bss:0000000000000001 UART_RxTail
     /tmp/ccSYqJT4.s:536    .bss:0000000000000005 UART_RxBuf
                             .bss:0000000000000000 UART_LastRxError
     /tmp/ccSYqJT4.s:187    .text:0000000000000056 __vector_19
     /tmp/ccSYqJT4.s:534    .bss:0000000000000004 UART_TxHead
     /tmp/ccSYqJT4.s:532    .bss:0000000000000003 UART_TxTail
     /tmp/ccSYqJT4.s:538    .bss:0000000000000025 UART_TxBuf
     /tmp/ccSYqJT4.s:254    .text:00000000000000aa uart_init
     /tmp/ccSYqJT4.s:306    .text:00000000000000dc uart_getc
     /tmp/ccSYqJT4.s:361    .text:0000000000000112 uart_putc
     /tmp/ccSYqJT4.s:405    .text:000000000000013c uart_puts
     /tmp/ccSYqJT4.s:439    .text:0000000000000154 uart_puts_p
     /tmp/ccSYqJT4.s:485    .text:0000000000000172 uart_available
     /tmp/ccSYqJT4.s:512    .text:000000000000018c uart_flush

UNDEFINED SYMBOLS
__divmodhi4
__do_clear_bss
